## Clojurescript with Node modules

##### Because JS is fun

In this introduction we are going to have a look at a few things.

1. Setting up a project.clj
2. Requiring a module
3. Basic Stream I/O
4. Using express

## Setting up a project.clj

First, what is it. Project.clj is a configuration file for leiningen a CLI tool that compiles CLJS -> JS. Similar to Gruntfile.js to Grunt or package.json (more or less).

You will need to install leiningen. They have a nice website and installation steps available [leiningen.org](http://leiningen.org/#install)

*beginning was omitted see full file [here](https://gist.github.com/piatra/7851658)*

````
  :cljsbuild {
    :builds {
             :dev {
                   :source-paths ["src-cljs"]
                   :compiler {:output-to "dest/index.js"
                              :optimizations :simple
                              :target :nodejs}}
````
The configuration file allows lein to watch the source file and compile automatically.
You can start the watch task by using

````
$ lein cljsbuild auto dev
````
This will ensure that every time you hit save lein will automatically re compile the code.
Be sure to be in the correct folder and to have the project.clj file in the same location.

**auto** means it will watch and compile automatically. The alternative would be **once**.

**dev** refers to the build type we specified in the project.clj, we only have *dev*, you could also have a *production* step available.

## Requiring a module

To require a express in Node and create an app you would do:

````
var express = require('express')
    , app        = express();
````

The syntax is similar in CLJS

````
(ns node.main) ;; you have to declare a namespace first

(def express (js/require "express"))
(def app        (express))
````

I have skipped the basic http hello world example because there are other examples out there.

## Basic Stream I/O

First you need to include the **fs** module and I've also declared a *rs* variable (from read stream).

````
(def fs (js/require "fs"))
(def *rs* nil)
````
And now for reading and redirecting a stream

````
 (set! *rs* (.createReadStream fs "path_to_file"))
 (.pipe *rs* process.stdout)

````
In this example I am opening a read stream for a file and set it to the rs variable.
I then pipe the data to process.stdout which would be our terminal. And you can even access the **__dirname** variable to ensure the correct path. This is accessible via

````
(str js/__dirname "/static/file_name")
````
In this example I concatenated the current path with the string "/static/file_name". You might prefer to include the *path* node module instead.


## Everything together

````
(ns node.main)

(def express (js/require "express")) ;; require express
(def app        (express))                    ;; create the app
(def fs           (js/require "fs"))            ;; require fs
(def *rs* nil)

;; localhost:3000
(.get app "/" (fn [req res]
                (.send res "Hello world!")))

;; localhost:3000/user/andrei
(.get app "/user/:name" (fn [req res]
                     (.send res (aget req "params" "name"))))

;; localhost:3000/read
;; be sure to specify a valid path to read from
(.get app "/read"
      (fn [req res]
        (set! *rs* (.createReadStream fs "my_file"))
        (.pipe *rs* res)))

;; what port to bind the application on
(.listen app 3000)

(defn start [& _]
  (println "Server started on port 3000"))

;; must have a main function
(set! *main-cli-fn* start)
````
